#------------------------------------------------------------------------------
# Add a new empty line between each line
$ echo -ne "1\n2\n3\n" | sed 's/$/\n/g'
1

2

3


#------------------------------------------------------------------------------
# Aggregate lines
$ echo -ne "1\n2\n3\n" | perl -00pe 's/\n/ /g'
1 2 3 


#------------------------------------------------------------------------------
# Transform lines to list
echo -ne "AAA\nBBB\nCCC\n" | perl -00pe "s|^|<START>|sg" | perl -00pe "s|\n$|<END>|sg" | perl -pe "s/\n/<DELIM>/g"
<START>AAA<DELIM>BBB<DELIM>CCC<END>

# Transform to SQL list without quotes
echo -ne "1\n2\n3\n" | perl -00pe "s|^|(|sg" | perl -00pe "s|\n$|)|sg" | perl -pe "s/\n/,/g"
(1,2,3)

# Transform to SQL list with quotes
echo -ne "A\nB\nC\n" | perl -00pe "s|^|('|sg" | perl -00pe "s|\n$|')|sg" | perl -pe "s/\n/','/g"
('A','B','C')

# Transform to GREP list
echo -ne "A\nB\nC\n" | perl -00pe 's|^|"|sg' | perl -00pe 's|\n$|"|sg' | perl -pe "s/\n/\\\|/g"
"A\|B\|C"

# Transform to spaced list
echo -ne "A\nB\nC\n" | tr '\n' ' '
A B C 


#------------------------------------------------------------------------------
# Load files matching "AAA" without matching "BBB"
$ kate -n $(find . -name "*.ext" | xargs grep -L "BBB" | xargs grep -l "AAA")
$ kate -n $(find . -name "*.ext" | xargs grep -l "AAA" | xargs grep -L "BBB")


#------------------------------------------------------------------------------
# Grep with partial binary file
# https://stackoverflow.com/questions/9988379/how-to-grep-a-text-file-which-contains-some-binary-data
$ grep -e '<pattern>' file.log
Fichier binaire file.log correspondant
$ cat -v file.log | grep -e "<pattern>"

#------------------------------------------------------------------------------
# Grep datetime and extract some lines (with id)
# Re-Grep only these lines
$ egrep "^08:00:0" log | grep "Notification" > output
$ cat output | sed "s/.*'\(.*\)'/\1/g" | sort | uniq -c | egrep "\s*1 " | sed 's/.* \([^ ]*\)/\1/g' | head
id1
id2
id3
$ cat output | sed "s/.*'\(.*\)'/\1/g" | sort | uniq -c | egrep "\s*1 " | sed 's/.* \([^ ]*\)/\1/g' | perl -00pe 's|^|"|sg' | perl -00pe 's|\n$|"|sg' | perl -pe "s/\n/\\\|/g" > mygrep
$ grep -f "mygrep" output | less


#------------------------------------------------------------------------------
# Sed Replace only matched lines
sed -i '/pattern/s/string_scr/string_dest/g' file


#------------------------------------------------------------------------------
# Time elapsed in milliseconds between two lines (format %H:%M:%S.xxx) (diff) (v1)

echo "06:51:03.124 INFO   SUBSCRIBE on account [TOTO1]
06:51:08.547 INFO   SUBSCRIBE on account [TOTO2]
06:51:09.117 INFO   SUBSCRIBE on account [TOTO3]
06:51:09.311 INFO   SUBSCRIBE on account [TOTO4]
06:51:09.502 INFO   SUBSCRIBE on account [TOTO5]
06:51:09.739 INFO   SUBSCRIBE on account [TOTO6]" | sed 's@\(..:..:......\).*\[\(.*\)\].*@\1\|\2@g' | awk -F "|" 'BEGIN {
    previous_datetime=0
    new_datetime=0
    previous_account=""
} {
    current_datetime = $1

    cmd = "date +\"%s\" -d \""current_datetime"\""
    cmd | getline current_seconds
    close(cmd)

    cmd = "date +\"%N\" -d \""current_datetime"\""
    cmd | getline current_nano
    close(cmd)
    
    new_datetime = current_seconds * 1000 + current_nano / 1000000
        
    if (previous_datetime != 0)
    {       
        printf("%s %s\n", previous_account, new_datetime - previous_datetime); 
    }
    previous_account=$2
    previous_datetime = new_datetime;
} END {
    if (previous_datetime != 0)
    {
        printf("%s %s\n", previous_account, new_datetime - previous_datetime); 
    }
}
' | sort -k 2 -rn
TOTO1 5423
TOTO2 570
TOTO5 237
TOTO3 194
TOTO4 191
TOTO6 0

#------------------------------------------------------------------------------
# Time elapsed in milliseconds between two lines (format %H:%M:%S.xxx) (diff) (v2)
#!/bin/bash

echo "14:28:38.252609|START
14:28:38.531826|END
14:36:23.847652|START
14:36:24.033606|END" | awk -F "|" 'BEGIN { dt_start=0 }
function convert_string_to_millis(str) {
    current_datetime=$1

    cmd = "date +\"%s\" -d \""current_datetime"\""
    cmd | getline current_seconds
    close(cmd)

    cmd = "date +\"%N\" -d \""current_datetime"\""
    cmd | getline current_nano
    close(cmd)

    return ( current_seconds * 1000 + current_nano / 1000000 )
}
/START/ { dt_start=convert_string_to_millis($1); str_start=$1 }
/END/   { printf("%s | %s ms\n", str_start, convert_string_to_millis($1) - dt_start) }

$ ./elapsed.sh 
14:28:38.252609 | 279.217 ms
14:36:23.847652 | 185.954 ms

