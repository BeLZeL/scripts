#=============================================================================#
# DEBUG                                                                       #
#=============================================================================#


/bin/bash -x <script>
OR
#!/bin/bash
set -x


#=============================================================================#
# VARS                                                                        #
#=============================================================================#


#------------------------------------------------------------------
# Arguments in scripts
echo "$#" : nb args
echo "$@" : args
echo "$1" : first arg
echo "$?" : returned result

#------------------------------------------------------------------
# Use eval
$ touch test.toto
$ T="-name '*.toto'"
$ find . $T
$ eval find . $T
./test.toto


#=============================================================================#
# OTHERS                                                                      #
#=============================================================================#


#------------------------------------------------------------------
# https://dougvitale.wordpress.com/2011/12/21/deprecated-linux-networking-commands-and-their-replacements/
# Deprecated Linux networking commands and their replacements
arp -------> ip n (ip neighbor)
ifconfig --> ip a (ip addr), ip link, ip -s (ip -stats)
iptunnel --> ip tunnel
iwconfig --> iw
nameif ----> ip link, ifrename
netstat ---> ss, ip route (for netstat-r), ip -s link (for netstat -i), ip maddr (for netstat-g)
route -----> ip r (ip route)

#------------------------------------------------------------------
# Perform a lock to launch a script only one at a time
#!/bin/bash
LOCKFILE=/tmp/lock.tmp
[ -e "${LOCKFILE}" ] && exit || touch "${LOCKFILE}"
sleep 10
rm -f ${LOCKFILE}

#------------------------------------------------------------------
# Compress and split
tar -cvJf test.txz *
gpg -c test.txz
cat test.txz.gpg | split -b 500k --numeric-suffixes --additional-suffix .txz.gpg - split_

# Compress and split (one line)
FILE=test ; tar -cvJf ${FILE}.txz * ; gpg -c ${FILE}.txz ; cat ${FILE}.txz.gpg | split -b 250k --numeric-suffixes --additional-suffix .txz.gpg - split_ ; rm -f ${FILE}.txz ${FILE}.txz.gpg

# Unsplit and Decompress
cat split_* > test.txz.gpg
gpg -d test.txz.gpg > test.txz
tar -xvJf test.txz

+ script de compilation make et cmake

#------------------------------------------------------------------
# Debian Version
$ lsb_release -a                                                                                                               
No LSB modules are available.                                                                                                                                
Distributor ID: Debian                                                                                                                                       
Description:    Debian GNU/Linux 8.5 (jessie)                                                                                                                
Release:        8.5                                                                                                                                          
Codename:       jessie

#------------------------------------------------------------------
# memory of a process with name
$ ps -p $(pidof BINNAME) -o vsz= -o rsz= | awk '{ printf "%s %s\n", $1/1024, $2/1024 } '
7468.25 13.168

#------------------------------------------------------------------
# pgrep
$ pgrep firefox : will list all processes whose commands match firefox
$ pgrep -f firefox : will list all processes whose entire command lines match firefox
$ pgrep -x firefox : will list all processes whose commands exactly match firefox

#------------------------------------------------------------------------------
# Launch command until timeout
timeout 5m netcat {ip} {port} > dump.txt

#------------------------------------------------------------------------------
# Watch with differences
watch -d ...

#------------------------------------------------------------------------------
# Watch with pipe
$ watch 'date | cut -d" " -f4'
08:30:15

#------------------------------------------------------------------------------
# Access denied
sudo iptables -I INPUT -s <ip> -j REJECT

#------------------------------------------------------------------------------
# Sequence
$ seq 1 3 | tr '\n' '-'
1-2-3-
$ seq -f "%02.0f" 1 3 | tr '\n' '-'
01-02-03-


#=============================================================================#
# STRING                                                                      #
#=============================================================================#


#------------------------------------------------------------------------------
# Padding or pretty print
$ n=2
$ echo $n
2
$ printf '%02d' $n
02

#------------------------------------------------------------------------------
# Remove or get extension filename
$ f="toto.tutu.txt"
$ echo ${f%.txt}
toto.tutu
$ echo ${f#*.}
tutu.txt
$ echo ${f##*.}
txt

#------------------------------------------------------------------------------
# Starts with, ends with
$ res="ERROR: truc"

$ echo "${res}"
ERROR: truc

$ echo "${res::6}"
ERROR:

$ echo "${res#* }"
truc

$ echo "${res% *}"
ERROR:


#------------------------------------------------------------------------------
# See hexadecimal or try ghex (GNOME hex editor)
hexdump -C <file>

#------------------------------------------------------------------------------
# Indirection parameter, variable whose name is the value of another variable, substitution
$ env | grep HISTSIZE
HISTSIZE=15000
$ myvar=HISTSIZE
$ echo ${!myvar}
15000


#=============================================================================#
# DATE                                                                        #
#=============================================================================#


#------------------------------------------------------------------------------
# Difference between Dates
falcon_heavy='20180206'
echo "scale=0; ( `date +"%s"` - `date -d "$falcon_heavy" +"%s"` ) / (24*3600) + 1" | bc -l

#------------------------------------------------------------------------------
# Difference between millis
val1=$(date +%S.%N -d "00:00:12.400")
val2=$(date +%S.%N -d "00:00:06.700")
echo "$val2 / $val1" | bc -l
.54032258064516129032
echo "( 1 - $val2 / $val1 ) * 100 " | bc -l | cut -d'.' -f1
45

#------------------------------------------------------------------------------
# Month period of previous year
for m in {1..12};
do
    first_day=$(date -d "$m/1 - 1 year" "+%Y%m%d")
    last_day=$(date -d "$m/1 - 1 year + 1 month - 1 day" "+%Y%m%d")
    echo "${first_day} ${last_day}"
done
20180101 20180131
20180201 20180228
20180301 20180331
20180401 20180430
20180501 20180531
20180601 20180630
20180701 20180731
20180801 20180831
20180901 20180930
20181001 20181031
20181101 20181130
20181201 20181231


#=============================================================================#
# FILES / DIRS / SYMLINKS                                                     #
#=============================================================================#


#------------------------------------------------------------------------------
# Search target of a symlink
readlink <link name>

#------------------------------------------------------------------------------
# Change target of a symlink
ln -nfs <new target> <link name>

Example :
$ mkdir 1 2
$ touch 1/1.txt 2/2.txt
$ ln -nfs 1 first
$ ln -nfs 2 second
$ ln -nfs first master
$ ls master
master/1.txt
$ ln -nfs second master
$ ls master
master/2.txt

#------------------------------------------------------------------------------
# du with hidden files/folders
du -sch .[!.]* * | sort -rh | head

#------------------------------------------------------------------------------
# Rename file's extension or create dir/subdirs easily
mv /big/path/truc.{txt,csv}
mkdir -p {projectA,projectB}/{src,lib,test}

#------------------------------------------------------------------------------
# Rename multiple files
touch toto.1
touch toto.2
touch toto.3
rename 's/^toto./prefix.toto./g' toto.*
ll
prefix.toto.1
prefix.toto.2
prefix.toto.3

#------------------------------------------------------------------------------
# Create and go to new directory
mkdir <dir> && cd $_

#------------------------------------------------------------------------------
# List a remote directory
rsync -avz user@server:~/remote_dir


#=============================================================================#
# FIND                                                                        #
#=============================================================================#


#------------------------------------------------------------------
# Find a file and execute a specific command for each one
/tmp/toto$ ls
./toto1.txt
./toto2.txt
./toto3.txt

/tmp/toto$ find . -name "toto*" -exec ls {} \;
./toto1.txt
./toto2.txt
./toto3.txt

/tmp/toto$ find . -name "toto*" -exec grep -H sdf {} \;
./toto1.txt:sdf
./toto1.txt:sdffgtfy

/tmp/toto$ find . -name "toto*" -exec grep -l sdf {} \;
./toto1.txt

#------------------------------------------------------------------
# Copy some files and preserve tree view
$ find . -name "*.ext" -exec cp --parents {} </PATH/> \;

#------------------------------------------------------------------------------
# Find and delete empty files 
find . -size 0c -delete
find . -size 0c -type f -name "*" -exec rm {} \;
find . -name "*.log" -size 0 | xargs rm

#------------------------------------------------------------------------------
# Find recently modified files
find . -cmin -<minutes> -name "*"
find . -ctime -<days> -name "*"

#------------------------------------------------------------------------------
# Find empty and recent files
find . -size 0c -ctime -2 -type f -name "*" -exec ls -l {} \;

#------------------------------------------------------------------------------
# Find big files
find . -size +100M -type f -name "*" -exec ls -l {} \;

#------------------------------------------------------------------------------
# Find old files (> 1 year)
find . -type f -mtime +365
find . -type f -mtime +365 -exec ls -l {} \;
find . -type f -mtime +365 -delete

#------------------------------------------------------------------------------
# Find oldest files
find -type f -printf '%T+ %p\n' | sort | head -1

#------------------------------------------------------------------------------
# Find duplicate files (doublons, twice)
find -not -empty -type f -print0 | xargs -0 md5sum | sort | uniq -w32 --all-repeated=separate | less

#------------------------------------------------------------------------------
# Find symlink whose contents match pattern
find / -lname <target> 2>/dev/null

#------------------------------------------------------------------------------
# Find first sub-directories
find ~/git -mindepth 1 -maxdepth 1 -type d

#------------------------------------------------------------------------------
# Sum of filesize
find . -type f -name "*.log" -exec ls -l {} \; | awk '{ total += $5 } END { print total / 1024 / 1024, "Mo" }'


#=============================================================================#
# JOIN                                                                        #
#=============================================================================#


$ cat /tmp/1.txt
A|1
B|2
C|3

$ cat /tmp/2.txt
A|3
B|2
D|4

$ join -j1 -t'|' /tmp/1.txt /tmp/2.txt
A|1|3
B|2|2

$ join -j1 -t'|' -o 1.1,1.2,2.2 /tmp/1.txt /tmp/2.txt
A|1|3
B|2|2

$ join -a1 -a2 -e'-' -j1 -t'|' -o 1.1,1.2,2.1,2.2 /tmp/1.txt /tmp/2.txt
A|1|A|3
B|2|B|2
C|3|-|-
-|-|D|4


#=============================================================================#
# SHORTCUTS                                                                   #
#=============================================================================#


Alt + . : find previous args
Ctrl + Alt + e : extend alias (ls *txt -> ls --color=auto *txt)
Ctrl + x then * : extend globs (ls *txt -> ls file1.txt file2.txt file3.txt)
Ctrl + x then Ctrl + e : open command in vim and execute it


#=============================================================================#
# OTHERS                                                                      #
#=============================================================================#


#------------------------------------------------------------------------------
# Open file with default application
xdg-open toto.jpg


#------------------------------------------------------------------------------
# Case insensitive search with less
-> use the command "-i" inside less

#------------------------------------------------------------------------------
# Array
$ echo ${#test[*]}
0
$ test[${#test[*]}]=zero
$ test[${#test[*]}]=un
$ test[${#test[*]}]=deux
$ test[${#test[*]}]=trois
$ echo ${test[@]}
zero un deux trois
$ echo ${#test[@]}
4
$ echo ${!test[@]}
0 1 2 3
$ echo ${test[2]}
deux

#------------------------------------------------------------------------------
# Split string to array, and use ${ARRargs[0]} or ${#ARRargs[*]}
ARRargs=(${args// / })
    
#------------------------------------------------------------------------------
# Array Join (https://zaiste.net/posts/how_to_join_elements_of_an_array_in_bash/)
$ SOURCES=("TOTO" "TUTU")
$ function join_by { local IFS="$1"; shift; echo "$*"; }
$ join_by '/' "${SOURCES[@]}"
TOTO/TUTU

#------------------------------------------------------------------------------
# Array Uniq Sort (manage valid whitespace)
$ array=("a c" b f "5 3") ; IFS=$'\n' sorted=($(sort -u <<< "${array[*]}")) ; unset IFS ; printf "[%s]\n" "${sorted[@]}"
[5 3]
[a c]
[b]
[f]

#------------------------------------------------------------------------------
# Array Uniq Sort (manage valid whitespace without IFS)
$ array=(a c b "f f" 3 5)
$ readarray -t sorted < <(printf '%s\n' "${array[@]}" | sort -u)
$ printf "[%s]\n" "${sorted[@]}"
[3]
[5]
[a]
[b]
[c]
[f f]

#------------------------------------------------------------------------------
# Short Bash test, do echo condition is false

[ 1 -eq 0 ] || {
    echo "Pass here if condition is false"
}

# Equivalent to 
# if [ ! 1 -eq 0 ]
# then
#     echo "Pass here if condition is false"
# fi

#------------------------------------------------------------------------------
# Short Bash test, do echo condition is true

[ 1 -eq 1 ] && {
    echo "Pass here if condition is true"
}

# Equivalent to 
# if [ 1 -eq 1 ]
# then
#     echo "Pass here if condition is true"
# fi

#------------------------------------------------------------------------------
# Short Bash test (if then else)
# https://www.commitstrip.com/fr/2014/05/16/russian-roulette/
[ $(( $RANDOM % 6 )) == 0 ] && echo "Argh" || echo "Lucky Boy";

# Equivalent to 
# if [ $(( $RANDOM % 6 )) == 0 ]
# then
#     echo "Argh"
# else
#     echo "Lucky Boy"
# fi

#------------------------------------------------------------------------------
#Another version of cat

res=$(cat $file)
res=$(< $file)


#=============================================================================#
# PACKAGING                                                                   #
#=============================================================================#


#------------------------------------------------------------------------------
# Find files from package
dpkg-query -L <package name>

#------------------------------------------------------------------------------
# Installed Package version
dpkg -l $(dpkg -S <regex package name> 2>/dev/null | cut -d':' -f1)
dpkg -l <exact package name>

#------------------------------------------------------------------------------
# NOT Installed Package version
apt-cache policy <package name>

#------------------------------------------------------------------------------
# Find package name with filename
# http://www.commentcamarche.net/faq/6947-trouver-a-quel-paquet-appartient-un-fichier
dpkg -S <file>

#------------------------------------------------------------------------------
# Watch and build or upload 
while true; do
    inotifywait --quiet --recursive -e MODIFY --exclude 'swp$' .
    [...] make or rsync [...]
done

#------------------------------------------------------------------------------
# Dependencies
aptitude why <package name>



#=============================================================================#
# GDB                                                                         #
#=============================================================================#


function gdb_clean()
{
    BINAIRE=$1
    CORE=$2
    FILE=$(tempfile)
 
    echo "thread apply all bt" > ${FILE}
    gdb ${BINAIRE} ${CORE} -x ${FILE} --batch | tr '\n' ';' | sed 's|;;|;\n|g' \
        | grep -v 'pthread_cond_wait' \
        | grep -v 'poll' \
        | tr ';' '\n'  | less
 
    rm -fr $FILE
}

$ gdb_clean ./binary core


#=============================================================================#
# TOP                                                                         #
#=============================================================================#


$ top
Inside top, tape 'o', then 'COMMAND=<string>'


#=============================================================================#
# ALIAS / FUNCTION                                                            #
#=============================================================================#


#----------------------------------------------------------
# Alias
alias w='ssh -l www'
alias r='ssh -l root'
alias jessie64='schroot -c jessie-64 -p'
alias ll='ls -l'

#----------------------------------------------------------
# Functions

# Show name of functions (typeset is obsolete)
declare -F

# Show code of functions
declare -f <name>


#=============================================================================#
# EOF                                                                         #
#=============================================================================#
