#------------------------------------------------------------------
# Compress and split
tar -cvJf test.txz *
gpg -c test.txz
cat test.txz.gpg | split -b 500k --numeric-suffixes --additional-suffix .txz.gpg - split_

# Compress and split (one line)
FILE=test ; tar -cvJf ${FILE}.txz * ; gpg -c ${FILE}.txz ; cat ${FILE}.txz.gpg | split -b 250k --numeric-suffixes --additional-suffix .txz.gpg - split_ ; rm -f ${FILE}.txz ${FILE}.txz.gpg

# Unsplit and Decompress
cat split_* > test.txz.gpg
gpg -d test.txz.gpg > test.txz
tar -xvJf test.txz

+ script de compilation make et cmake

#------------------------------------------------------------------
# Debian Version
$ lsb_release -a                                                                                                               
No LSB modules are available.                                                                                                                                
Distributor ID: Debian                                                                                                                                       
Description:    Debian GNU/Linux 8.5 (jessie)                                                                                                                
Release:        8.5                                                                                                                                          
Codename:       jessie

#------------------------------------------------------------------
# memory of a process with name
$ ps -p $(pidof BINNAME) -o vsz= -o rsz= | awk '{ printf "%s %s\n", $1/1024, $2/1024 } '
7468.25 13.168

#------------------------------------------------------------------
# pgrep
$ pgrep firefox : will list all processes whose commands match firefox
$ pgrep -f firefox : will list all processes whose entire command lines match firefox
$ pgrep -x firefox : will list all processes whose commands exactly match firefox


#------------------------------------------------------------------------------
# C'est pratique, la commande timeout
timeout 5m netcat {ip} {port} > dump.txt
Et hop, 5min de flux, pas besoin de surveiller.


#------------------------------------------------------------------------------
# Watch with differences
watch -d ...


#------------------------------------------------------------------------------
# Access denied
sudo iptables -I INPUT -s <ip> -j REJECT


#=============================================================================#
# STRING                                                                      #
#=============================================================================#


#------------------------------------------------------------------------------
# Remove ext
$ filename_ext="toto.txt"
$ echo ${filename_ext%.txt}
toto


#=============================================================================#
# DATE                                                                        #
#=============================================================================#


#------------------------------------------------------------------------------
# Difference between Dates
falcon_heavy='20180206'
echo "scale=0; ( `date +"%s"` - `date -d "$falcon_heavy" +"%s"` ) / (24*3600) + 1" | bc -l

#------------------------------------------------------------------------------
# Difference between millis
val1=$(date +%S.%N -d "00:00:12.400")
val2=$(date +%S.%N -d "00:00:06.700")
echo "$val2 / $val1" | bc -l
.54032258064516129032
echo "( 1 - $val2 / $val1 ) * 100 " | bc -l | cut -d'.' -f1
45


#=============================================================================#
# FIND                                                                        #
#=============================================================================#


#------------------------------------------------------------------
# Find a file and execute a specific command for each one
/tmp/toto$ ls
./toto1.txt
./toto2.txt
./toto3.txt

/tmp/toto$ find . -name "toto*" -exec ls {} \;
./toto1.txt
./toto2.txt
./toto3.txt

/tmp/toto$ find . -name "toto*" -exec grep -H sdf {} \;
./toto1.txt:sdf
./toto1.txt:sdffgtfy

/tmp/toto$ find . -name "toto*" -exec grep -l sdf {} \;
./toto1.txt

#------------------------------------------------------------------
# Copy some files and preserve tree view
$ find . -name "*.ext" -exec cp --parents {} </PATH/> \;

#------------------------------------------------------------------------------
# Find and delete empty files 
find . -size 0c -type f -name "*" -exec rm {} \;
find . -name "*.log" -size 0 | xargs rm

#------------------------------------------------------------------------------
# Find recently modified files
find . -cmin -<minutes> -name "*"
find . -ctime -<days> -name "*"

#------------------------------------------------------------------------------
# Find empty and recent files
find . -size 0c -ctime -2 -type f -name "*" -exec ls -l {} \;

#------------------------------------------------------------------------------
# Find big files
find . -size +100M -type f -name "*" -exec ls -l {} \;


#=============================================================================#
# SHORTCUTS                                                                   #
#=============================================================================#

Alt + . : find previous args
Ctrl + Alt + e : extend alias (ls *txt -> ls --color=auto *txt)
Ctrl + x then * : extend globs (ls *txt -> ls file1.txt file2.txt file3.txt)
Ctrl + x then Ctrl + e : open command in vim and execute it


#=============================================================================#
# OTHERS                                                                      #
#=============================================================================#


#------------------------------------------------------------------------------
# du with hidden files/folders
du -sch .[!.]* * | sort -rh | head


#------------------------------------------------------------------------------
# Open file with default application
xdg-open toto.jpg


#------------------------------------------------------------------------------
# Case insensitive search with less
-> use the command "-i" inside less


#------------------------------------------------------------------------------
# Tunnel
home@linux $ ssh -4 -N -f -L 2345:localhost:5432 user@remote
home@linux $ psql -U user -h localhost bdd_name

#------------------------------------------------------------------------------
# Reverse Tunnel
home@linux $ ssh -TN -R8086:localhost:8086 user@remote
user@remote $ curl -i -XPOST 'http://localhost:8086/write?db=mydb' --data-binary 'temperature,machine=unit42 internal=42'


#------------------------------------------------------------------------------
# Rename file's extension or create dir/subdirs easily
mv /big/path/truc.{txt,csv}
mkdir -p {projectA,projectB}/{src,lib,test}

#------------------------------------------------------------------------------
# Rename multiple files
touch toto.1
touch toto.2
touch toto.3
rename 's/^toto./prefix.toto./g' toto.*
ll
prefix.toto.1
prefix.toto.2
prefix.toto.3

#------------------------------------------------------------------------------
# Create and go to new directory
mkdir <dir> && cd $_

#------------------------------------------------------------------------------
# List a remote directory
rsync -avz user@server:~/remote_dir

#------------------------------------------------------------------------------
# Array
$ echo ${#test[*]}
0
$ test[${#test[*]}]=zero
$ test[${#test[*]}]=un
$ test[${#test[*]}]=deux
$ test[${#test[*]}]=trois
$ echo ${test[@]}
zero un deux trois
$ echo ${#test[@]}
4
$ echo ${!test[@]}
0 1 2 3
$ echo ${test[2]}
deux

#------------------------------------------------------------------------------
# Array Join (https://zaiste.net/posts/how_to_join_elements_of_an_array_in_bash/)
$ SOURCES=("TOTO" "TUTU")
$ function join_by { local IFS="$1"; shift; echo "$*"; }
$ join_by '/' "${SOURCES[@]}"
TOTO/TUTU

#------------------------------------------------------------------------------
# Array Uniq Sort (manage valid whitespace)
$ array=("a c" b f "5 3") ; IFS=$'\n' sorted=($(sort -u <<< "${array[*]}")) ; unset IFS ; printf "[%s]\n" "${sorted[@]}"
[5 3]
[a c]
[b]
[f]

#------------------------------------------------------------------------------
# Array Uniq Sort (manage valid whitespace without IFS)
$ array=(a c b "f f" 3 5)
$ readarray -t sorted < <(printf '%s\n' "${array[@]}" | sort -u)
$ printf "[%s]\n" "${sorted[@]}"
[3]
[5]
[a]
[b]
[c]
[f f]

#------------------------------------------------------------------------------
# Short Bash test, do echo condition is false

[ 1 -eq 0 ] || {
    echo "Pass here if condition is false"
}

# Equivalent to 
# if [ ! 1 -eq 0 ]
# then
#     echo "Pass here if condition is false"
# fi

#------------------------------------------------------------------------------
# Short Bash test, do echo condition is true

[ 1 -eq 1 ] && {
    echo "Pass here if condition is true"
}

# Equivalent to 
# if [ 1 -eq 1 ]
# then
#     echo "Pass here if condition is true"
# fi

#------------------------------------------------------------------------------
# Short Bash test (if then else)
# https://www.commitstrip.com/fr/2014/05/16/russian-roulette/
[ $(( $RANDOM % 6 )) == 0 ] && echo "Argh" || echo "Lucky Boy";

# Equivalent to 
# if [ $(( $RANDOM % 6 )) == 0 ]
# then
#     echo "Argh"
# else
#     echo "Lucky Boy"
# fi

#------------------------------------------------------------------------------
#Another version of cat

res=$(cat $file)
res=$(< $file)


#=============================================================================#
# PACKAGING                                                                   #
#=============================================================================#


#------------------------------------------------------------------------------
# Find files from package
dpkg-query -L <package name>

#------------------------------------------------------------------------------
# Installed Package version
dpkg -l $(dpkg -S <regex package name> 2>/dev/null | cut -d':' -f1)
dpkg -l <exact package name>

#------------------------------------------------------------------------------
# NOT Installed Package version
apt-cache policy <package name>

#------------------------------------------------------------------------------
# Find package from file
# http://www.commentcamarche.net/faq/6947-trouver-a-quel-paquet-appartient-un-fichier
dpkg -S <file>

#------------------------------------------------------------------------------
# Watch and build or upload 
while true; do
    inotifywait --quiet --recursive -e MODIFY --exclude 'swp$' .
    [...] make or rsync [...]
done


#=============================================================================#
# GDB                                                                         #
#=============================================================================#


function gdb_clean()
{
    BINAIRE=$1
    CORE=$2
    FILE=$(tempfile)
 
    echo "thread apply all bt" > ${FILE}
    gdb ${BINAIRE} ${CORE} -x ${FILE} --batch | tr '\n' ';' | sed 's|;;|;\n|g' \
        | grep -v 'pthread_cond_wait' \
        | grep -v 'poll' \
        | tr ';' '\n'  | less
 
    rm -fr $FILE
}

$ gdb_clean ./binary core

#=============================================================================#
# EOF                                                                         #
#=============================================================================#

